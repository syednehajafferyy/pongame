<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pong Game</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="gameContainer">
        <canvas id="pongCanvas" width="800" height="500"></canvas>
        <div id="scoreBoard">
            <span id="leftScore">0</span> : <span id="rightScore">0</span>
        </div>
    </div>
    <script>
       const canvas = document.getElementById('pongCanvas');
const ctx = canvas.getContext('2d');

// Base game size for calculations (responsive)
const BASE_WIDTH = 800;
const BASE_HEIGHT = 500;

// Actual game state variables
let width = BASE_WIDTH;
let height = BASE_HEIGHT;

// Responsive resize
function resizeCanvas() {
    // Set canvas width/height attributes (not just CSS)
    const parent = canvas.parentElement;
    let w = parent.offsetWidth;
    let h = parent.offsetHeight;

    // Maintain aspect ratio 16:10 (800:500)
    let aspect = 16/10;
    if (w/h > aspect) {
        w = h * aspect;
    } else {
        h = w / aspect;
    }

    canvas.width = width = Math.min(w, BASE_WIDTH);
    canvas.height = height = Math.min(h, BASE_HEIGHT);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Paddle and ball sizes are proportional to canvas size
function getSizes() {
    return {
        paddleWidth: Math.round(width * 0.015),
        paddleHeight: Math.round(height * 0.16),
        ballSize: Math.round(width * 0.02),
        leftPaddleX: Math.round(width * 0.025),
        rightPaddleX: Math.round(width * 0.975 - width * 0.015),
        aiSpeed: Math.max(3, Math.round(width * 0.006))
    };
}

function resetGameObjects() {
    const sizes = getSizes();
    leftPaddle.x = sizes.leftPaddleX;
    leftPaddle.y = height/2 - sizes.paddleHeight/2;
    leftPaddle.width = sizes.paddleWidth;
    leftPaddle.height = sizes.paddleHeight;

    rightPaddle.x = sizes.rightPaddleX;
    rightPaddle.y = height/2 - sizes.paddleHeight/2;
    rightPaddle.width = sizes.paddleWidth;
    rightPaddle.height = sizes.paddleHeight;
    rightPaddle.speed = sizes.aiSpeed;

    ball.x = width/2 - sizes.ballSize/2;
    ball.y = height/2 - sizes.ballSize/2;
    ball.size = sizes.ballSize;
    ball.speedX = sizes.aiSpeed * 2 * (Math.random() > 0.5 ? 1 : -1);
    ball.speedY = sizes.aiSpeed * 1.3 * (Math.random() > 0.5 ? 1 : -1);
}
let leftPaddle = {};
let rightPaddle = {};
let ball = {};
resetGameObjects();

let leftScore = 0;
let rightScore = 0;

// Paddle control (mouse/touch)
function setLeftPaddleY(y) {
    leftPaddle.y = y - leftPaddle.height/2;
    leftPaddle.y = Math.max(0, Math.min(height - leftPaddle.height, leftPaddle.y));
}
canvas.addEventListener('mousemove', function(e) {
    const rect = canvas.getBoundingClientRect();
    let mouseY = (e.clientY - rect.top) * height / rect.height;
    setLeftPaddleY(mouseY);
});
canvas.addEventListener('touchmove', function(e) {
    if (e.touches.length > 0) {
        const rect = canvas.getBoundingClientRect();
        let touchY = (e.touches[0].clientY - rect.top) * height / rect.height;
        setLeftPaddleY(touchY);
    }
}, {passive: false});

// Net
function drawNet() {
    ctx.strokeStyle = "#ffb6d5";
    ctx.lineWidth = Math.max(2, Math.round(width * 0.004));
    for(let i = 0; i < height; i += Math.round(height * 0.06)) {
        ctx.beginPath();
        ctx.moveTo(width/2, i);
        ctx.lineTo(width/2, i + Math.round(height * 0.04));
        ctx.stroke();
    }
}

// Draw paddle
function drawRect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, w, h);
}

// Draw ball
function drawBall(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
    ctx.fill();
}

// Reset ball
function resetBall() {
    const sizes = getSizes();
    ball.x = width/2 - sizes.ballSize/2;
    ball.y = height/2 - sizes.ballSize/2;
    ball.size = sizes.ballSize;
    ball.speedX = sizes.aiSpeed * 2 * (Math.random() > 0.5 ? 1 : -1);
    ball.speedY = sizes.aiSpeed * 1.3 * (Math.random() > 0.5 ? 1 : -1);
}

// Responsive reset on resize
window.addEventListener('resize', () => {
    resizeCanvas();
    resetGameObjects();
});

// AI movement
function updateAI() {
    let targetY = ball.y + ball.size/2 - rightPaddle.height/2;
    if (rightPaddle.y < targetY) {
        rightPaddle.y += rightPaddle.speed;
    } else if (rightPaddle.y > targetY) {
        rightPaddle.y -= rightPaddle.speed;
    }
    rightPaddle.y = Math.max(0, Math.min(height - rightPaddle.height, rightPaddle.y));
}

// Collision
function checkCollision(paddle) {
    if (
        ball.x < paddle.x + paddle.width &&
        ball.x + ball.size > paddle.x &&
        ball.y < paddle.y + paddle.height &&
        ball.y + ball.size > paddle.y
    ) {
        ball.speedX = -ball.speedX;
        let impact = ((ball.y + ball.size/2) - (paddle.y + paddle.height/2)) / (paddle.height/2);
        ball.speedY += impact * 2;
        if (paddle === leftPaddle) {
            ball.x = paddle.x + paddle.width;
        } else {
            ball.x = paddle.x - ball.size;
        }
    }
}

// Game logic
function update() {
    ball.x += ball.speedX;
    ball.y += ball.speedY;

    if (ball.y <= 0) {
        ball.y = 0;
        ball.speedY = -ball.speedY;
    }
    if (ball.y + ball.size >= height) {
        ball.y = height - ball.size;
        ball.speedY = -ball.speedY;
    }

    checkCollision(leftPaddle);
    checkCollision(rightPaddle);

    if (ball.x < 0) {
        rightScore++;
        document.getElementById('rightScore').textContent = rightScore;
        resetBall();
    }
    if (ball.x + ball.size > width) {
        leftScore++;
        document.getElementById('leftScore').textContent = leftScore;
        resetBall();
    }

    updateAI();
}

// Drawing
function draw() {
    ctx.clearRect(0, 0, width, height);

    drawNet();

    drawRect(leftPaddle.x, leftPaddle.y, leftPaddle.width, leftPaddle.height, "#fff");
    drawRect(rightPaddle.x, rightPaddle.y, rightPaddle.width, rightPaddle.height, "#fff");

    drawBall(ball.x, ball.y, ball.size, "#ff69b4"); // Pink ball
}

// Animation loop
function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}
gameLoop();
    </script>
</body>
</html>
